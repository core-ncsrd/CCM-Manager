from flask import Flask, jsonify, request
from pymongo import MongoClient
from werkzeug.utils import secure_filename
import os
import logging
import subprocess
from datetime import datetime
from dotenv import load_dotenv
import json

app = Flask(__name__)

# Configuration settings
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # Limit to 16 MB
client: MongoClient = MongoClient('mongodb://localhost:27017/')
db = client.mydatabase
collection = db.mycollection
load_dotenv()

UPLOAD_FOLDER = './sboms'
TMP_FOLDER = './tmp'
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
os.makedirs(TMP_FOLDER, exist_ok=True)
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
ALLOWED_EXTENSIONS = {'txt'}

# Set up detailed logging
logging.basicConfig(level=logging.DEBUG)

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

@app.route('/')
def home():
    return jsonify({"message": "Flask API with MongoDB is running"})

@app.route('/generate_sbom', methods=['POST'])
def generate_sbom():
    try:
        if 'file' not in request.files:
            return jsonify({"error": "No file part in request"}), 400

        requirements_file = request.files['file']

        if requirements_file.filename == '':
            return jsonify({"error": "No file selected"}), 400

        if not allowed_file(requirements_file.filename):
            return jsonify({"error": "Only .txt files are allowed"}), 400

        # Save the requirements file temporarily
        requirements_filename = secure_filename(requirements_file.filename)
        tmp_filepath = os.path.join(TMP_FOLDER, f'{datetime.now().strftime("%Y%m%d%H%M%S")}_{requirements_filename}')
        requirements_file.save(tmp_filepath)

        # Generate SBOM JSON file path
        timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
        sbom_filepath = os.path.join(UPLOAD_FOLDER, f'sbom_{timestamp}.json')

        # Run SBOM generation script
        subprocess.run(['./generate_sbom.sh', tmp_filepath, timestamp], check=True)

        # Check if SBOM file was created
        if not os.path.exists(sbom_filepath):
            return jsonify({"error": "Failed to generate SBOM"}), 500

        # Run create_project.sh and pass the SBOM file path as an argument
        logging.debug(f"This is the FILE PATH: {sbom_filepath}")
        result = subprocess.run(
            ['./create_project.sh', sbom_filepath],
            capture_output=True,
            text=True,
            env={**os.environ}
        )
        
        logging.debug(f"|||||||||||||||||||||||||||: {result.returncode}")
        logging.debug(f"Create project script output: {result.stdout}")
        logging.error(f"Create project script stderr: {result.stderr}")
        if result.returncode != 0:
            logging.error(f"Error creating project: {result.stderr}")
            return jsonify({
                "error": "Failed to create project",
                "details": result.stderr,
                "stdout": result.stdout
            }), 500

        # Read the VEX JSON file generated by get_vulnerabilities.sh
        vex_files = sorted([f for f in os.listdir(UPLOAD_FOLDER) if f.startswith('vex_') and f.endswith('.json')], reverse=True)
        if vex_files:
            vex_filepath = os.path.join(UPLOAD_FOLDER, vex_files[0])
            with open(vex_filepath, 'r') as vex_file:
                vex_data = json.load(vex_file)

            # Save the VEX data in MongoDB
            collection.insert_one({
                'sbom_filepath': sbom_filepath,
                'vulnerabilities': vex_data
            })

            return jsonify({"message": "SBOM generated, project created, and vulnerabilities saved successfully", "sbom_file": sbom_filepath}), 200
        else:
            return jsonify({"error": "Failed to retrieve vulnerabilities"}), 500

    except Exception as e:
        logging.error(f"An error occurred: {e}")
        return jsonify({"error": "Internal server error"}), 500

@app.route('/show_vulnerabilities', methods=['GET'])
def get_vulnerabilities():
    try:
        # Fetch all vulnerabilities from the MongoDB collection
        vulnerabilities = list(collection.find({}, {'_id': 0}))  # Exclude the MongoDB ID field

        if vulnerabilities:
            return jsonify(vulnerabilities), 200
        else:
            return jsonify({"message": "No vulnerabilities found"}), 404

    except Exception as e:
        logging.error(f"An error occurred while fetching vulnerabilities: {e}")
        return jsonify({"error": "Internal server error"}), 500

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5001, debug=True)